#Connection Pool (Пул соединений)

### Что узнаешь
1. Как работает пул соединений
2. Try с ресурсами и AutoClosable
3. Блоки инициализации

###В чем проблема?
Каждый раз когда мы делаем так

   ```java
    Connection connection = DriverManager.getConnection(dbURL, dbProperties);
   ```

мы открываем соединение к базе данных. Это процесс небыстрый, особенно если подключаться к базе на удаленном 
сервере(как это обычно и бывает), а не твоем компукторе. Если делать таким образом, то 9/10 времени обработки запроса 
будет тратиться на подключение к базе.

###Что такое пул соединений?
Пул соединений — это что-то вроде контейнера, который хранит определенное количество открытых соединений. Соединения 
открываются один раз, а далее мы будем работать с уже открытыми соединениями.
Когда нам нужно сделать запрос, мы будем вызывать метод пула, который вернет нам одно из открытых соединений.
После выполнения запроса, мы будем возвращать соединения обратно в пул. 

Также нужно учитывать, что сервер может обрабатывать много запросов одновременно. На каждый запрос выделяется
отдельный поток. Поэтому пул соединений должен следить за тем, чтобы вследствие многопоточности не получалось, что
одно соединение используется в многих местах одновременно и других конфузов.

### Гайд по созданию пула
####ProxyConnection
Для удобства создадим обертку над Connection. Суть в том, что когда мы в коде получаем соединение в `try` с ресурсами
   ```java
        try (Connection connection = DriverManager.getConnection(dbURL, dbProperties);
            ...
        }
   ```
после выполнения блока `try` автоматически вызывается `connection.close()`, так как Connection наследует AutoCloseable. 
Про это почитай [здесь](https://javanerd.ru/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-java/try-%D1%81-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%B0%D0%BC%D0%B8/).
Мы хотим чтобы соединения не закрывались на самом деле, а возвращались в пул соединений. Поэтому делаем следующее:
1. Создаем класс `ProxyConnection`, имплементим его от `Connection`.
2. Создаем поле в котором будет лежать настоящий объект `Connection` и конструктор, принимающий `Connection` и инициализирующий поле.
3. Реализуем метод `close()`, возвращая этот `ProxyConnection` в пул соединений.
4. Реализуем все методы `Connection`, просто вызывая эти методы на нашем поле с настоящим соединением.
5. Добавляем метод в `ProxyConnection`, который действительно закроет настоящий `Connection`, вызвав на нем метод `close()`.

Я реализовывал [так](ProxyConnection.java)(можно подсмотреть).

####Пул
Пул должен быть один на все приложение(`singleton`). Под соединениями далее понимается `ProxyConnection`.
1. Поля:
   1. Коллекция для открытых свободных соединений(например [такая](http://java-online.ru/concurrent-queue-block.xhtml)) `availableConnections`
   2. Коллекция для открытых занятых соединений `unavailableConnections`
   3. Количество открытых соединений `capacity`
   4. Таймаут получения соединения `timeout`
   
2. Методы(и не только)
   1. Метод или что-то [другое](https://vertex-academy.com/tutorials/ru/bloki-inicializacii-v-java-chast-1/) для инициализации
      данных. Здесь нужно единожды проинициализировать начальные данные(прочитать проперти для базы, открыть соединения 
      к базе и засунуть их в `availableConnections`)
   2. `public Connection getConnection()`: пробуем достать подключение из `availableConnections` в течение `timeout`;
   если получили, помещаем его в `unavailableConnections` и возвращаем, если нет, то возвращаем `null` или бросаем исключение.
   3. `void returnConnection(ProxyConnection connection)`: проверяем, есть ли `connection` в `unavailableConnections`(если нет,
      то нам пытаются вернуть левое соединение); убираем `connection` из `unavailableConnections` и возвращаем в `availableConnections`.
   4. `public void closePool()`: закрываем все соединения в пуле(по-настоящему).
   
### Задание
1. Реализовать классы `ProxyConnection` и `ConnectionPool`.
2. В коде поменять открытие подключений на получение подключений из пула.