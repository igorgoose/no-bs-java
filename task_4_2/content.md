# Connection Pool 2 + Dependency Injection (Внедрение зависимостей)

### Подключение пула соединений HikariCP

Пул соединений используется в каждом приложении, которое работает с базой данных.
Было бы странно, если бы каждый заново реализовывал его для своего приложения.
Поэтому люди создают библиотеки, которые содержат часто используемый функционал.
Задачей будет подключить пул соединений HikariCP. Гайд по подключению 
[здесь](https://www.baeldung.com/hikaricp). 

### Dependency Injection + Inversion of Control

При написании приложений часто бывает, что мы пишем код с целью добавить функционал как можно быстрее любой ценой.
В таких случаях нередко мы не думаем о том, что позднее нам скорее всего придется изменять функционал, 
а может и заменять его полностью. В итоге полчаса, которые мы сохранили в первый раз, превращаются в десятки часов
унылых однообразных изменений в миллионе мест в коде и еще десятки часов фикса багов, возникших из-за того, что мы забыли
поменять в миллион первом месте.

Для избежания таких ситуаций мы должны стараться следовать принципам [SOLID](https://habr.com/ru/company/productivity_inside/blog/505430/).
А конкретнее принципу **Open-Closed**(O из SOLID). Вкратце, он говорит что мы должны писать код так, чтобы при необходимости 
добавить/изменить функционал мы меняли старый код как можно меньше и вместо этого добавляли новый.

Сегодня мы постараемся добиться того, что при добавлении нового функционала, нам нужно будет менять всего одну строку.
В этом нам помогут **Dependency Injection**(внедрение зависимостей) и **Inversion of Control**(инверсия управления).
Возможно, звучит очень умно, но на самом деле это вещи, к которым можно прийти самому, если попытаться придумать, как бы 
упростить изменение кода.

Про **Dependency Injection** почитай [здесь](https://habr.com/ru/post/350068/). \
Про **Inversion of Control**. Вкратце, в нашем случае это означает, что ответственность за создание объектов и внедрение 
в них зависимостей отвечает третья сторона(не программист, и не сами классы, которые создаются). Эту третью сторону называют
[DI-Container](https://habr.com/ru/post/350708/) (DI от Dependency Injection).

## Задача
1. Создать еще один пул подключений с помощью библиотеки HikariCP(унаследовать оба пула подключения от одного интерфейса).
2. Проверить, что везде используются интерфейсы, а не конкретные классы.
3. Реализовать создание и настройку всех служебных объектов в одном месте(можно переписать `ApplicationConfig`).
   1. Создать метод run(). В нем мы создадим все объекты, внедрим необходимые зависимости в созданные объекты, запустим контроллер.
   2. В методе run() создаем объекты поочереди. Сначала, те, которые можем создать просто так, потом те, которые можем создать 
   с помощью созданных объектов и т.д. Если для создания какого-то объекта нам подходят несколько объектов одного интерфейса,
      разрешать эту ситуацию как описано ниже.
      
   3. Разрешаем конфликты. Нужно создать файл `application.properties`, в котором мы будем указывать, какой объект использовать
   для внедрения зависимостей. Например, для ConnectionPool мы можем указать проперти в `application.properties`:
      ```
      dependencies.connection-pool=HikariConnectionPool
      ```
   
      В коде мы можем выбирать нужный объект, сравнивая его имя класса со значением проперти(имя класса можно получить через
      `obj.getClass().getSimpleName()`). 
      
   4. После создания всех методов запускаем метод `run()` контроллера.
   
4. В `main()` запускаем `ApplicationConfig.run()`.

### ЗЫ
1. Можно забить на синглтоны, так как мы считаем, что за создание всех служебных объектов отвечает `ApplicationConfig`.
Вне него служебные объекты не создаются, поэтому сколько объектов создастся в `ApplicationConfig`, столько их и будет. 
   Если вдруг будет больше одного служебного объекта на класс, это косяк `ApplicationConfig`.
   
2. `application.properties` нужно прочитать в самом начале `ApplicationConfig.run()`.

### Итог
При такой настройке мы можем создавать классы, наследующиеся от одного интерфейса и подменять из во всем коде, изменяя 
значения пропертей в `application.properties`. В итоге получаем одну измененную строку, и то в файле конфигурации.
Конечно, в реальной жизни это все делается полностью автоматически без нашего участия (как в `Spring Framework`). Но мы 
это делаем вручную в маленьком проекте, чтобы понять, как примерно это происходит и зачем это нужно.